class Queue:
    def __init__(self, max_size):
        self.__items = [None]*(max_size + 1)
        self.__first = 0
        self.__last = 0

    def is_empty(self):
        return self.__first == self.__last

    def is_full(self):
        return (self.__last + 1) % len(self.__items) == self.__first

    def push(self, item):
        if self.is_full():
            raise Exception("Queue is full")
        self.__items[self.__last] = item
        self.__last = (self.__last + 1) % len(self.__items)

    def pop(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        item = self.__items[self.__first]
        self.__first = (self.__first + 1) % len(self.__items)
        return item


def get_distances(A, x):
    '''Compute distances between x and every city
    in the distance matrix A'''
    n = len(A)
    dist = [-1]*n
    q = Queue(n)

    dist[x] = 0
    q.push(x)
    while(not q.is_empty()):
        y = q.pop()
        print(f'y: {y}')
        for i in range(n):
    
            if A[y][i] == 1 and dist[i] == -1:
                dist[i] = dist[y] + 1
                q.push(i)
    return dist

A = [
    [0, 0, 1, 1, 1, 0],
    [0, 0, 0, 0, 0, 1],
    [0, 1, 0, 0, 1, 0],
    [0, 0, 0, 0, 1, 1],
    [0, 1, 0, 0, 0, 1],
    [0, 1, 0, 0, 0, 0]
]
B = [
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
]

start = B[3][3]
end=B[7][2]

dist = get_distances(A, start)
print(dist)



moves=[
      [-1,-2],
      [1,-2],
      [2,-1],
      [2,1],
       [1,2],
       [-1,2],
       [-2,1],
       [-2,-1]
      ]

pos=[3,3]

for n in moves:
 
    pos_destino=[pos[0]+n[0], pos[1]+n[1]]
    B[pos_destino[0]][pos_destino[1]]+=1
    print(pos_destino)

    x=pos_destino[2]
    y= pos_destino[1]
    print(f'y: {y}')
    print(f'x: {x}')


for linha in B:
    print(linha)

